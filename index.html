<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Псевдо-3D — текстурированные стены</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Segoe UI,Roboto,Arial}
    .wrap{display:flex;flex-direction:column;height:100%}
    header{padding:8px 12px;background:#0e0e0e;border-bottom:1px solid #222}
    header h1{margin:0;font-size:16px;font-weight:600}
    #game{flex:1;display:flex;align-items:stretch;position:relative}
    canvas{background:#555;display:block;margin:auto;max-width:100%;height:auto}
    .hud{width:280px;min-width:220px;padding:12px;background:#0f0f0f;border-left:1px solid #222}
    .hint{font-size:13px;line-height:1.5;color:#bbb}
    .small{font-size:12px;color:#999}
    footer{padding:8px 12px;background:#0e0e0e;border-top:1px solid #222;font-size:13px}
    #joystickControls{position:fixed;bottom:20px;left:20px;display:none;z-index:20;}
    #rotationButtons{position:fixed;bottom:20px;right:20px;display:none;flex-direction:column;gap:6px;z-index:20;}
    #rotationButtons button{width:60px;height:40px;font-size:16px;}
    /* стили кнопки режима */
    #modeBtn{position:fixed;top:10px;right:10px;z-index:30;padding:8px 10px;border-radius:6px;background:#222;color:#ddd;border:1px solid #333}
    /* стили джойстика */
    #joystick{width:140px;height:140px;border-radius:50%;background:rgba(0,0,0,0.25);position:relative;touch-action:none;}
    #stick{width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.95);position:absolute;left:40px;top:40px;transform:translate(0,0);transition:transform 0.03s linear;}
    /* карта сверху (в левом углу на canvas) — рисуется прямо в основном canvas */
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Псевдо-3D — текстуры, джойстик и карта сверху</h1>
    </header>
    <div id="game">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="hud">
        <div class="hint">Информация:</div>
        <div class="small" id="info">Загрузка...</div>
        <hr/>
        <div class="hint">Подсказки:</div>
        <div class="small">W/A/S/D — движение, Q/E — поворот, R — рестарт</div>
      </div>
    </div>
    <footer>Raycaster с повторяющейся пиксельной текстурой стен.</footer>
  </div>

  <button id="modeBtn">Mobile управление: выкл</button>

  <div id="joystickControls">
    <div id="joystick">
      <div id="stick"></div>
    </div>
  </div>

  <div id="rotationButtons">
    <button id="turnLeft">⟲</button>
    <button id="turnRight">⟳</button>
  </div>

<script>
/* -----------------------
   Конфигурация и карта
   ----------------------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

const TILE = 64;
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,1,1,1,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,1,0,0,1],
  [1,0,1,1,0,0,0,0,1,0,0,1],
  [1,0,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,1,1,1,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1],
];
const MAP_W = MAP[0].length, MAP_H = MAP.length;

/* -----------------------
   Игрок
   ----------------------- */
let player = {
  x: TILE * 2.5,
  y: TILE * 2.5,
  dir: 0,
  fov: Math.PI / 3,
  speed: 140
};

/* -----------------------
   Текстура стены (твоя картинка)
   Путь использует локальный путь, который у тебя в сессии:
   /mnt/data/1000003058.png
   ----------------------- */
const wallTexture = new Image();
wallTexture.src = "/mnt/data/1000003058.png"; // <-- путь к твоему файлу
let wallTexLoaded = false;
wallTexture.onload = () => { wallTexLoaded = true; console.log('Текстура загружена', wallTexture.width, wallTexture.height); };
wallTexture.onerror = ()=>{ console.warn('Ошибка загрузки текстуры. Проверь путь или доступность файла.'); };

/* -----------------------
   Управление
   ----------------------- */
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('blur', ()=>{ for(let k in keys) keys[k]=false; });

function resetPlayer(){ player.x = TILE*2.5; player.y = TILE*2.5; player.dir = 0; }

/* -----------------------
   Raycasting + отрисовка с текстурой
   ----------------------- */
function isWall(x,y){
  const tx = Math.floor(x / TILE), ty = Math.floor(y / TILE);
  if(tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) return true;
  return MAP[ty][tx] !== 0;
}

function castRays(){
  // количество лучей — по ширине канваса (можешь уменьшить для perf)
  const numRays = W;
  const halfH = H / 2;
  const angleStep = player.fov / numRays;

  // небо и пол
  const skyGrad = ctx.createLinearGradient(0,0,0,halfH);
  skyGrad.addColorStop(0,'#7fb7e6');
  skyGrad.addColorStop(1,'#5f9bd1');
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,halfH);
  ctx.fillStyle = '#1f1f1f'; ctx.fillRect(0,halfH,W,halfH);

  let angle = player.dir - player.fov/2;
  for(let i=0;i<numRays;i++, angle += angleStep){
    // направление луча
    const rx = Math.cos(angle), ry = Math.sin(angle);

    // шаговый обход луча (простая, но надёжная реализация)
    let distance = 0;
    let hit = false;
    let hitX = 0, hitY = 0;

    const maxDist = 1200;
    while(!hit && distance < maxDist){
      distance += 1;
      const px = player.x + rx * distance;
      const py = player.y + ry * distance;
      const mapX = Math.floor(px / TILE), mapY = Math.floor(py / TILE);
      if(mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H){
        hit = true; break;
      }
      if(MAP[mapY][mapX] > 0){
        hit = true;
        hitX = px; hitY = py;
        break;
      }
    }

    // убираем \"рыбий глаз\"
    const correctedDist = distance * Math.cos(angle - player.dir) + 0.0001;
    const wallHeight = (TILE * H) / correctedDist;

    // вычисляем смещение попадания по текстуре (0..1)
    // берем дробную часть координаты в пределах тайла.
    let hitOffset = 0;
    if(hit){
      // используем ту координату, у которой ближайшая граница тайла (чтобы текстура не зеркалилась)
      const fracX = (hitX % TILE) / TILE;
      const fracY = (hitY % TILE) / TILE;
      // выбираем более выраженную дробную часть
      hitOffset = (Math.abs(fracX - 0.5) > Math.abs(fracY - 0.5)) ? fracX : fracY;
      // нормализация
      if(hitOffset < 0) hitOffset += 1;
    }

    const x = i; // позиция по экрану (ширина полосы = 1)
    // затемнение в зависимости от расстояния
    const shade = Math.max(0.18, 1 - correctedDist / 900);

    if(wallTexLoaded && hit){
      // вычисляем X-координату в текстуре (целый пиксель)
      const texX = Math.floor(hitOffset * wallTexture.width) % wallTexture.width;
      // рисуем 1-пиксельную вертикальную полоску текстуры, растягивая по высоте стены
      try {
        ctx.drawImage(
          wallTexture,
          texX, 0, 1, wallTexture.height,                       // источник: 1px по ширине
          x, halfH - wallHeight/2, 1, wallHeight                // целевой прямоугольник
        );
        // наложение тёмного слоя для расстояния (пиксельный эффект сохранён)
        if(shade < 0.99){
          ctx.fillStyle = `rgba(0,0,0,${1 - shade})`;
          ctx.fillRect(x, halfH - wallHeight/2, 1, wallHeight);
        }
      } catch(e){
        // на случай проблем с drawImage (например CORS) fallback
        ctx.fillStyle = `rgb(${Math.floor(180*shade)},${Math.floor(180*shade)},${Math.floor(180*shade)})`;
        ctx.fillRect(x, halfH - wallHeight/2, 1, wallHeight);
      }
    } else {
      // fallback: однотонная стена
      ctx.fillStyle = `rgb(${Math.floor(180*shade)},${Math.floor(180*shade)},${Math.floor(180*shade)})`;
      ctx.fillRect(x, halfH - wallHeight/2, 1, wallHeight);
    }
  }
}

/* -----------------------
   Мини-карта сверху (рисуется поверх 3D в левом верхнем углу)
   ----------------------- */
function drawMinimap(){
  const scale = 0.18;
  const pad = 6;
  const mapWpx = MAP_W * TILE * scale;
  const mapHpx = MAP_H * TILE * scale;
  // фон минимапы
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(pad-2, pad-2, mapWpx+4, mapHpx+4);
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      ctx.fillStyle = MAP[y][x] ? '#999' : '#1b1b1b';
      ctx.fillRect(pad + x*TILE*scale, pad + y*TILE*scale, TILE*scale, TILE*scale);
    }
  }
  // игрок
  ctx.fillStyle = '#ff4';
  ctx.beginPath();
  ctx.arc(pad + player.x*scale, pad + player.y*scale, 4, 0, Math.PI*2);
  ctx.fill();
  // направление
  ctx.strokeStyle = '#f00';
  ctx.beginPath();
  ctx.moveTo(pad + player.x*scale, pad + player.y*scale);
  ctx.lineTo(pad + player.x*scale + Math.cos(player.dir)*12, pad + player.y*scale + Math.sin(player.dir)*12);
  ctx.stroke();
}

/* -----------------------
   Обновление состояния
   ----------------------- */
function update(dt){
  const moveStep = player.speed * dt;
  const rotSpeed = 2.6;
  let moveX = 0, moveY = 0;

  if(keys['w']||keys['arrowup']){ moveX += Math.cos(player.dir) * moveStep; moveY += Math.sin(player.dir) * moveStep; }
  if(keys['s']||keys['arrowdown']){ moveX -= Math.cos(player.dir) * moveStep; moveY -= Math.sin(player.dir) * moveStep; }
  if(keys['a']){ moveX += Math.cos(player.dir - Math.PI/2) * moveStep; moveY += Math.sin(player.dir - Math.PI/2) * moveStep; }
  if(keys['d']){ moveX += Math.cos(player.dir + Math.PI/2) * moveStep; moveY += Math.sin(player.dir + Math.PI/2) * moveStep; }

  // столкновения
  const nx = player.x + moveX, ny = player.y + moveY;
  if(!isWall(nx, player.y)) player.x = nx; else player.x += (Math.sign(moveX)||0)*2;
  if(!isWall(player.x, ny)) player.y = ny; else player.y += (Math.sign(moveY)||0)*2;

  if(keys['q']) player.dir -= rotSpeed * dt;
  if(keys['e']) player.dir += rotSpeed * dt;
  if(keys['r']) resetPlayer();

  // HUD
  const info = document.getElementById('info');
  info.innerText = `x: ${player.x.toFixed(1)} y: ${player.y.toFixed(1)} dir: ${(player.dir%(Math.PI*2)).toFixed(2)} tex: ${wallTexLoaded? 'ok':'..'}`;
}

/* -----------------------
   Игровой цикл
   ----------------------- */
let last = performance.now();
function loop(now){
  const dt = (now - last) / 1000; last = now;
  update(dt);
  castRays();
  drawMinimap();
  requestAnimationFrame(loop);
}
resetPlayer();
requestAnimationFrame(loop);

/* -----------------------
   Мобильный джойстик + кнопки поворота
   ----------------------- */
const modeBtn = document.getElementById('modeBtn');
const joystickControls = document.getElementById('joystickControls');
const rotationButtons = document.getElementById('rotationButtons');
const joyArea = document.getElementById('joystick');
const stick = document.getElementById('stick');

let mobileMode = false;
modeBtn.onclick = ()=>{
  mobileMode = !mobileMode;
  joystickControls.style.display = mobileMode ? 'block' : 'none';
  rotationButtons.style.display = mobileMode ? 'flex' : 'none';
  modeBtn.innerText = 'Mobile управление: ' + (mobileMode ? 'вкл' : 'выкл');
};

// Джойстик
let activePointerId = null;
let joyX = 0, joyY = 0;
const maxRadius = 40, deadzone = 0.18;

function setStickPosition(px, py){ stick.style.transform = `translate(${px}px, ${py}px)`; }

function updateJoyFromPoint(clientX, clientY){
  const rect = joyArea.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  let dx = clientX - cx, dy = clientY - cy;
  const dist = Math.hypot(dx, dy);
  if(dist > maxRadius){ dx = dx/dist * maxRadius; dy = dy/dist * maxRadius; }
  setStickPosition(dx, dy);
  joyX = dx / maxRadius;
  joyY = dy / maxRadius;
  if(Math.abs(joyX) < deadzone) joyX = 0;
  if(Math.abs(joyY) < deadzone) joyY = 0;
}

function resetStick(){ joyX = 0; joyY = 0; setStickPosition(0,0); activePointerId = null; }

joyArea.addEventListener('pointerdown', (ev)=>{ joyArea.setPointerCapture(ev.pointerId); activePointerId = ev.pointerId; updateJoyFromPoint(ev.clientX, ev.clientY); });
joyArea.addEventListener('pointermove', (ev)=>{ if(activePointerId !== ev.pointerId) return; updateJoyFromPoint(ev.clientX, ev.clientY); });
joyArea.addEventListener('pointerup', (ev)=>{ if(activePointerId !== ev.pointerId) return; joyArea.releasePointerCapture(ev.pointerId); resetStick(); });
joyArea.addEventListener('pointercancel', ()=>{ resetStick(); });

// применяем джойстик к клавишам
setInterval(()=>{
  keys['w'] = (joyY < -0.01);
  keys['s'] = (joyY > 0.01);
  keys['a'] = (joyX < -0.01);
  keys['d'] = (joyX > 0.01);
}, 16);

// кнопки поворота камеры
document.getElementById('turnLeft').addEventListener('pointerdown', ()=> keys['q'] = true);
document.getElementById('turnLeft').addEventListener('pointerup', ()=> keys['q'] = false);
document.getElementById('turnRight').addEventListener('pointerdown', ()=> keys['e'] = true);
document.getElementById('turnRight').addEventListener('pointerup', ()=> keys['e'] = false);

/* -----------------------
   Подстройка отображения под окно
   ----------------------- */
function fitCanvas(){
  const containerW = Math.min(window.innerWidth - 320, 1200);
  const containerH = window.innerHeight - 120;
  const aspect = W / H;
  let cw = containerW, ch = Math.round(cw / aspect);
  if(ch > containerH){ ch = containerH; cw = Math.round(ch * aspect); }
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

</script>
</body>
</html>
