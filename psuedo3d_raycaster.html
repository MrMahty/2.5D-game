<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Псевдо-3D игра — минимальный Raycaster</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Segoe UI,Roboto,Arial}
    .wrap{display:flex;flex-direction:column;height:100%}
    header{padding:8px 12px;background:#0e0e0e;border-bottom:1px solid #222}
    header h1{margin:0;font-size:16px;font-weight:600}
    #game{flex:1;display:flex;align-items:stretch}
    canvas{background:#555;display:block;margin:auto;max-width:100%;height:auto}
    .hud{width:280px;min-width:220px;padding:12px;background:#0f0f0f;border-left:1px solid #222}
    .hint{font-size:13px;line-height:1.5;color:#bbb}
    .controls{margin-top:12px}
    .small{font-size:12px;color:#999}
    footer{padding:8px 12px;background:#0e0e0e;border-top:1px solid #222;font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Псевдо-3D (raycaster) — вставьте в HTML и откройте в браузере</h1>
    </header>
    <div id="game">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="hud">
        <div class="hint">Управление:</div>
        <div class="controls small">
          W / ↑ — вперёд<br>
          S / ↓ — назад<br>
          A / ← — влево (крен) | D / → — вправо (крен)<br>
          Q / E — поворот<br>
          R — рестарт (в центр)
        </div>
        <hr />
        <div class="hint">Информация:</div>
        <div class="small" id="info">Загрузка...</div>
        <hr />
        <div class="hint">Карта (вид сверху):</div>
        <canvas id="map" width="260" height="260" style="border:1px solid #222;margin-top:8px"></canvas>
        <div class="small" style="margin-top:8px">Нажмите R для перезапуска позиции.</div>
      </div>
    </div>
    <footer>Минимальный демонстрационный движок: простой рейткастер без текстур — все стены рисуются цветом и затемнением.</footer>
  </div>
<script>
/* Минимальный raycaster (псевдо-3D). Можно копировать как один HTML-файл и запускать в браузере. */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const mapCanvas = document.getElementById('map');
const mctx = mapCanvas.getContext('2d');
const info = document.getElementById('info');
let W = canvas.width, H = canvas.height;

// Простая карта: 0 = пусто, 1 = стена
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,1,1,1,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,1,0,0,1],
  [1,0,1,1,0,0,0,0,1,0,0,1],
  [1,0,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,1,1,1,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];
const MAP_W = MAP[0].length, MAP_H = MAP.length;
const TILE = 64; // логическая единица

// Игрок
let player = {
  x: TILE * 2.5,
  y: TILE * 2.5,
  dir: 0, // угол в радианах
  fov: Math.PI/3, // поле зрения
  speed: 140, // px/sec
};

// Контроль
const keys = {};
window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()] = true});
window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()] = false});
window.addEventListener('blur',()=>{for(let k in keys) keys[k]=false});

function resetPlayer(){player.x = TILE * 2.5; player.y = TILE * 2.5; player.dir = 0;}

// Raycasting
function castRays(dt){
  const numRays = W; // 1 луч на пиксель ширины
  const halfH = H/2;
  const stripWidth = 1; // ширина полосы
  const angleStep = player.fov / numRays;
  let angle = player.dir - player.fov/2;

  // отрисуем небо и пол
  // небо - верхняя половина
  const skyGrad = ctx.createLinearGradient(0,0,0,halfH);
  skyGrad.addColorStop(0,'#87ceeb');
  skyGrad.addColorStop(1,'#6aa6d6');
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,halfH);
  // пол
  const floorGrad = ctx.createLinearGradient(0,halfH,0,H);
  floorGrad.addColorStop(0,'#6b6b6b');
  floorGrad.addColorStop(1,'#222');
  ctx.fillStyle = floorGrad; ctx.fillRect(0,halfH,W,halfH);

  for(let i=0;i<numRays;i++, angle += angleStep){
    // нормализация

    let rx = Math.cos(angle), ry = Math.sin(angle);
    // шаг по лучу
    let distance = 0, hit = false, hx=0, hy=0, side=0;
    const maxDist = 1000;
    while(!hit && distance < maxDist){
      distance += 1; // шаг в пикселях логического мира
      const testX = Math.floor((player.x + rx*distance) / TILE);
      const testY = Math.floor((player.y + ry*distance) / TILE);
      if(testX < 0 || testX >= MAP_W || testY < 0 || testY >= MAP_H){
        hit = true; distance = maxDist; break;
      }
      if(MAP[testY][testX] > 0){ hit = true; hx = testX; hy = testY; }
    }
    // корректируем расстояние для устранения эффекта "рыбий глаз"
    const correctedDist = distance * Math.cos(angle - player.dir);
    // высота полосы
    const wallHeight = (TILE * H) / (correctedDist + 0.0001);
    const x = i*stripWidth;

    // затемнение по расстоянию
    let shade = Math.max(0.2, 1 - correctedDist / 800);
    // чуть различать стороны стен по координатам
    const baseColor = ((hx+hy)&1) ? [200,80,60] : [180,180,180];
    const r = Math.floor(baseColor[0]*shade);
    const g = Math.floor(baseColor[1]*shade);
    const b = Math.floor(baseColor[2]*shade);
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(x, halfH - wallHeight/2, stripWidth, wallHeight);
  }
}

let last = performance.now();
function step(now){
  const dt = (now - last)/1000; last = now;
  update(dt);
  castRays(dt);
  drawMap();
  requestAnimationFrame(step);
}

function update(dt){
  // движение
  const moveStep = player.speed * dt;
  const rotSpeed = 2.5; // rad/sec
  // forward/backward
  let moveX = 0, moveY = 0;
  if(keys['w'] || keys['arrowup']){ moveX += Math.cos(player.dir) * moveStep; moveY += Math.sin(player.dir) * moveStep; }
  if(keys['s'] || keys['arrowdown']){ moveX -= Math.cos(player.dir) * moveStep; moveY -= Math.sin(player.dir) * moveStep; }
  if(keys['a']){ // strafe left
    moveX += Math.cos(player.dir - Math.PI/2) * moveStep; moveY += Math.sin(player.dir - Math.PI/2) * moveStep;
  }
  if(keys['d']){ // strafe right
    moveX += Math.cos(player.dir + Math.PI/2) * moveStep; moveY += Math.sin(player.dir + Math.PI/2) * moveStep;
  }
  // collision simple
  const nx = player.x + moveX;
  const ny = player.y + moveY;
  if(!isWall(nx, player.y)) player.x = nx; else player.x += (Math.sign(moveX)||0)*4; // попытка чуть сдвинуть
  if(!isWall(player.x, ny)) player.y = ny; else player.y += (Math.sign(moveY)||0)*4;

  // поворот
  if(keys['q']) player.dir -= rotSpeed*dt;
  if(keys['e']) player.dir += rotSpeed*dt;

  // перезапуск
  if(keys['r']) resetPlayer();

  // информация в HUD
  info.innerText = `x: ${player.x.toFixed(1)} y: ${player.y.toFixed(1)} dir: ${ (player.dir%(Math.PI*2)).toFixed(2) }`;
}

function isWall(x, y){
  const tx = Math.floor(x / TILE);
  const ty = Math.floor(y / TILE);
  if(tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) return true;
  return MAP[ty][tx] !== 0;
}

function drawMap(){
  const scale = mapCanvas.width / (MAP_W * TILE);
  mctx.fillStyle = '#111'; mctx.fillRect(0,0,mapCanvas.width,mapCanvas.height);
  // клетки
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      if(MAP[y][x]) mctx.fillStyle = '#999'; else mctx.fillStyle = '#1b1b1b';
      mctx.fillRect(x*TILE*scale, y*TILE*scale, TILE*scale, TILE*scale);
    }
  }
  // игрок
  mctx.fillStyle = '#ff0';
  mctx.beginPath(); mctx.arc(player.x*scale, player.y*scale, 4,0,Math.PI*2); mctx.fill();
  // направление
  mctx.strokeStyle = '#f00'; mctx.beginPath(); mctx.moveTo(player.x*scale, player.y*scale);
  mctx.lineTo((player.x+Math.cos(player.dir)*30)*scale, (player.y+Math.sin(player.dir)*30)*scale); mctx.stroke();
}

// адаптация на изменение размера
function fitCanvas(){
  const containerW = Math.min(window.innerWidth - 300, 1200);
  const containerH = window.innerHeight - 120;
  const aspect = W / H;
  let cw = containerW, ch = Math.round(cw / aspect);
  if(ch > containerH){ ch = containerH; cw = Math.round(ch * aspect); }
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
}
window.addEventListener('resize', fitCanvas);

// старт
resetPlayer(); fitCanvas(); requestAnimationFrame(step);
</script>
</body>
</html>
